一、作业目的：

1、了解I2C协议的基本原理和时序协议；
一、基本原理
I2C协议仅需两根双向信号线即可工作，分别是SDA 和SCL，所有设备都连接在这两根总线上，通过 “主从模式” 进行数据交互。
主从架构：总线中只有一个主设备，负责发起通信、生成时钟信号和控制通信流程；可存在多个从设备，每个从设备有唯一的 7 位或 10 位地址，主设备通过地址选择要通信的从设备。
数据传输：SDA 线上的数据在 SCL 的高电平期间保持稳定，在 SCL 的低电平期间允许变化，确保主从设备能准确采样数据。
总线仲裁：若多个主设备同时发起通信，通过 “总线仲裁” 机制判断优先级，优先级高的主设备继续通信，低优先级的自动放弃，避免数据冲突。
二、核心时序协议
I2C 的完整通信流程由 “起始信号”“地址与读写位”“应答信号”“数据传输”“停止信号” 5 个关键时序组成，顺序不可颠倒。
1. 起始信号
触发条件：SCL 保持高电平时，SDA 由高电平跳转为低电平。
作用：向总线上所有从设备宣告 “即将开始通信”，所有从设备开始监听 SDA 线，准备接收地址。
2. 地址与读写位
传输内容：起始信号后，主设备先发送 7 位从设备地址，再发送 1 位 “读写位”，共 8 位。
从设备响应：所有从设备将接收的 7 位地址与自身地址对比，地址匹配的从设备会在第 8 位传输结束后，通过 SDA 线发送一个 “低电平应答信号”，表示已被选中。
3. 应答信号
ACK：接收方在接收完 8 位数据后，在 SCL 的高电平期间将 SDA 拉低，表示 “数据已正确接收”。
NACK：接收方在 SCL 高电平期间将 SDA 保持高电平，表示 “数据未接收” 或 “通信结束”
4. 数据传输
时序规则：每个数据字节为 8 位，主设备与从设备按 “8 位数据 + 1 位应答” 的格式传输，即每传 1 个字节，接收方必须回 1 个 ACK/NACK。
数据有效性：SCL 为高电平时，SDA 的电平状态代表数据（高 = 1，低 = 0），此时 SDA 不能变化；SCL 为低电平时，SDA 可切换电平，准备下一位数据。
5. 停止信号
触发条件：SCL 保持高电平时，SDA 由低电平跳转为高电平。
作用：向总线上所有设备宣告 “通信结束”，释放总线，允许其他主设备发起新的通信。
2、掌握0.96寸OLED屏的工作原理，汉字点阵显示原理；
一、0.96 寸 OLED 屏的工作原理
OLED屏无需背光，依靠有机材料通电自发光，0.96 寸是其常见尺寸，通常分辨率为 128×64 或 128×32 像素，工作原理可分为核心结构和驱动方式两部分。
二、汉字点阵显示原理
汉字是复杂图形，无法像字母那样用单个像素组合，需通过 “点阵” 将汉字拆分为规则的像素阵列，再控制对应像素发光显示。
3、掌握开源GUI库U82G在stm32上的移植编译方法，以及图形界面可视化技术
一、U8g2 库在 STM32 上的移植与编译步骤
U8g2 的核心是通过 “硬件接口适配层” 与 STM32 的外设（如 I2C、SPI）对接，再通过标准 C 库编译运行，步骤如下：
（1）添加 U8g2 源码到工程
从 U8g2 的csrc目录中复制以下文件到 STM32 工程的u8g2文件夹：
核心文件：u8g2.h、u8g2.c、u8x8.h、u8x8.c。
屏驱动文件：根据屏幕型号选择
接口驱动文件：根据通信方式选择
（2）实现硬件接口适配函数
U8g2 需要通过回调函数与 STM32 的 I2C/SPI 外设绑定
（3）配置 U8g2 初始化参数
在主函数中定义 U8g2 句柄，并初始化屏幕
（4）实现延时与 GPIO 函数
U8g2 需要延时函数（毫秒级）和 GPIO 控制
1、利用stm32f103的GPIO管脚、VCC和GND连接 OLED屏的I2C接口，采用cubemx设计一个HAL库程序框架，然后下载U82G源码，针对stm32f103和 0.96寸的I2C接口OLED屏，进行代码裁剪，然后移植到HAL程序程序中，完成OLED的各种显示，包括：
1）U82G的demo例程； 2）显示你自己的学号和名字（或网名昵称）；3）掌握上下、左右滑动显示方法；4）显示一个图案（比如你的头肖像），最好有动态效果。
一.keil创建一个新工程，并添加相应文件
(1).打开keil，点击project，new project,命名一个文件名并保存
(2).在之前建的文件里再新建三个文件夹
(3).打开固件库，找到启动文件，粘贴到Start文件夹下;
然后继续在固件库里找到“stm32f10x.h”,“system_stm3210x.c”和“system_stm3210x.h”三个文件，复制粘贴到文件夹下;在找到“core_cm3.c”和“core_cm3.h”的两个文件，复制粘贴到Start文件夹下，这样Start文件夹就添加完成
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fc5fd62e3399466983a1d40d3b84235e.png)
(4).找到标准外设驱动的文件夹，打开src,全选复制,，粘贴到Library文件夹下；然后打开inc；同样全部复制到Library文件下，Library文件夹配置完成
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b24d61cadc0f4706858d7cccc6576d97.png)
(5).最后打开Project（江协提供的资料中），打开STM32F10x_StdPeriph_ Template的文件，选择其中的main、conf还有两个it文件，复制粘贴到User文件夹下
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8316f6bcf7d74420b2a67bdc7e179c40.png)
(6)在keil中，点击“Manage Project Items”，删除默认组，新建“Stsrt”，“Library”，“User”和“Hareware”，选中“Start”，点击“Add Files”，添加之前添加到“Start”文件夹里面的文件，注意请先添加后缀为md的文件，然后再添加后缀为.c和.h的文件
（7）.选中“Library”，点击“Add Files”，添加之前添加到“Library”文件夹里面的文件
选中“User”，点击“Add Files”，添加之前添加到“User”文件夹里面的文件
选中“Hareware”，点击“Add Files”，添加之前添加到“Hareware”文件夹里面的文件
（8）在include paths栏，把添加的文件夹路径都添加进来
配置完成
（2）keil工程修改及编写
打开取字模，生成字模
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8c1c17a33fd3476caa7ca8e38d1fbaa6.png)
（3）编译烧录
FlyMcu进行烧录
（4）实验结果

[video(video-rWkPHhpV-1761920221716)(type-csdn)(url-https://live.csdn.net/v/embed/498664)(image-https://v-blog.csdnimg.cn/asset/a6d91b16c06a60873bd7adbd8e9d42c2/cover/Cover0.jpg)(title-1)]


上下或左右的滑动显示长字符
（1）STM32CubeMX建项目
（2）u8g2移植
代码如下
#include "u8g2.h"
void u8g2_Setup_ssd1306_i2c_128x64_noname_f(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
  uint8_t tile_buf_height;
  uint8_t *buf;
  u8g2_SetupDisplay(u8g2, u8x8_d_ssd1306_128x64_noname, u8x8_cad_ssd13xx_fast_i2c, byte_cb, gpio_and_delay_cb);
  buf = u8g2_m_16_8_f(&tile_buf_height);
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb, rotation);
}
（3）编写移植函数
在“Hardware”文件中新建一个stm32_u8g2.c和一个stm32_u8g2.h文档：
代码如下
stm32_u8g2.c：
#include "stm32_u8g2.h"
#include "tim.h"
#include "i2c.h"
uint8_t u8x8_byte_hw_i2c(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    /* u8g2/u8x8 will never send more than 32 bytes between START_TRANSFER and END_TRANSFER */
    static uint8_t buffer[128];
    static uint8_t buf_idx;
    uint8_t *data;
 
    switch (msg)
    {
    case U8X8_MSG_BYTE_INIT:
    {
        /* add your custom code to init i2c subsystem */
        MX_I2C2_Init(); //I2C初始化
    }
    break;
 
    case U8X8_MSG_BYTE_START_TRANSFER:
    {
        buf_idx = 0;
    }
    break;
 
    case U8X8_MSG_BYTE_SEND:
    {
        data = (uint8_t *)arg_ptr;
 
        while (arg_int > 0)
        {
            buffer[buf_idx++] = *data;
            data++;
            arg_int--;
        }
    }
    break;
 
    case U8X8_MSG_BYTE_END_TRANSFER:
    {
        if (HAL_I2C_Master_Transmit(&hi2c2, OLED_ADDRESS, buffer, buf_idx, 1000) != HAL_OK)
            return 0;
    }
    break;
 
    case U8X8_MSG_BYTE_SET_DC:
        break;
 
    default:
        return 0;
    }
 
    return 1;
}
uint8_t u8x8_gpio_and_delay(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    switch (msg)
    {
    case U8X8_MSG_DELAY_100NANO: // delay arg_int * 100 nano seconds
        __NOP();
        break;
    case U8X8_MSG_DELAY_10MICRO: // delay arg_int * 10 micro seconds
        for (uint16_t n = 0; n < 320; n++)
        {
            __NOP();
        }
        break;
    case U8X8_MSG_DELAY_MILLI: // delay arg_int * 1 milli second
        HAL_Delay(1);
        break;
    case U8X8_MSG_DELAY_I2C: // arg_int is the I2C speed in 100KHz, e.g. 4 = 400 KHz
        Tims_delay_us(5);
        break;                  
    case U8X8_MSG_GPIO_I2C_CLOCK: // arg_int=0: Output low at I2C clock pin
        break;                  
    case U8X8_MSG_GPIO_I2C_DATA:  // arg_int=0: Output low at I2C data pin
        break;                 
    case U8X8_MSG_GPIO_MENU_SELECT:
        u8x8_SetGPIOResult(u8x8,
        break;
    case U8X8_MSG_GPIO_MENU_NEXT:
        u8x8_SetGPIOResult(u8x8,
        break;
    case U8X8_MSG_GPIO_MENU_PREV:
        u8x8_SetGPIOResult(u8x8, 
        break;
    case U8X8_MSG_GPIO_MENU_HOME:
        u8x8_SetGPIOResult(u8x8,
        break;
    default:
        u8x8_SetGPIOResult(u8x8, 1);
        break;
    }
    return 1;
}

void u8g2Init(u8g2_t *u8g2)
{
	u8g2_Setup_ssd1306_i2c_128x64_noname_f(u8g2, U8G2_R0, u8x8_byte_hw_i2c, u8x8_gpio_and_delay); // 初始化u8g2 结构体
	u8g2_InitDisplay(u8g2);                                                                       // 
	u8g2_SetPowerSave(u8g2, 0);                                                                   // 
	u8g2_ClearBuffer(u8g2);
}
 
 
void draw(u8g2_t *u8g2)
{
	u8g2_ClearBuffer(u8g2); 
	
    u8g2_SetFontMode(u8g2, 1); 
    u8g2_SetFontDirection(u8g2, 0); 
    u8g2_SetFont(u8g2, u8g2_font_inb24_mf); 
    u8g2_DrawStr(u8g2, 0, 20, "U");
    
    u8g2_SetFontDirection(u8g2, 1);
    u8g2_SetFont(u8g2, u8g2_font_inb30_mn);
    u8g2_DrawStr(u8g2, 21,8,"8");
        
    u8g2_SetFontDirection(u8g2, 0);
    u8g2_SetFont(u8g2, u8g2_font_inb24_mf);
    u8g2_DrawStr(u8g2, 51,30,"g");
    u8g2_DrawStr(u8g2, 67,30,"\xb2");
    
    u8g2_DrawHLine(u8g2, 2, 35, 47);
    u8g2_DrawHLine(u8g2, 3, 36, 47);
    u8g2_DrawVLine(u8g2, 45, 32, 12);
    u8g2_DrawVLine(u8g2, 46, 33, 12);
  
    u8g2_SetFont(u8g2, u8g2_font_4x6_tr);
    u8g2_DrawStr(u8g2, 1,54,"github.com/olikraus/u8g2");
		
	u8g2_SendBuffer(u8g2);
	HAL_Delay(1000);
}
void testDrawPixelToFillScreen(u8g2_t *u8g2)
{
  int t = 1000;
	u8g2_ClearBuffer(u8g2);
 
  for (int j = 0; j < 64; j++)
  {
    for (int i = 0; i < 128; i++)
    {
      u8g2_DrawPixel(u8g2,i, j);
    }
  }
  HAL_Delay(1000);
}
stm32_u8g2.h：
#ifndef __STM32_U8G2_H
#define __STM32_U8G2_H
#include "main.h"
#include "u8g2.h"
#define u8         unsigned char  // ?unsigned char ????
#define MAX_LEN    128  //
#define OLED_ADDRESS  0x78 // oled
#define OLED_CMD   0x00  // 
#define OLED_DATA  0x40  // 

uint8_t u8x8_byte_hw_i2c(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr);
uint8_t u8x8_gpio_and_delay(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr);
void u8g2Init(u8g2_t *u8g2);
void draw(u8g2_t *u8g2);
void testDrawPixelToFillScreen(u8g2_t *u8g2); 
#endif
main.c：
int main(void)
{
  SystemClock_Config();
 
  MX_GPIO_Init();
  MX_I2C2_Init();
  MX_TIM1_Init();  
  u8g2_t u8g2;
  u8g2Init(&u8g2);	
  while (1)
  {

       u8g2_FirstPage(&u8g2);
       do
       {
				 draw(&u8g2);
 
				 u8g2DrawTest(&u8g2);
       } while (u8g2_NextPage(&u8g2));
		
 
  }
}
（3）keil工程编写
点击生成字模
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e9e8ea890b8e4c85872ad3fa4a21a681.png)
（4）实验结果

[video(video-dgKa2uOw-1761920262164)(type-csdn)(url-https://live.csdn.net/v/embed/498665)(image-https://v-blog.csdnimg.cn/asset/ce4643ef0baf07ab7efb9529dd026fc6/cover/Cover0.jpg)(title-2)]


2. 如果使用Keil的虚拟逻辑分析仪去采集 I2C 引脚SDA的波形，是什么样子的？ 如果无法采集到真实的I2C协议，你觉得可改用什么方法
Keil 的虚拟逻辑分析仪通过仿真 STM32 的 GPIO 引脚状态生成波形，对于 I2C 的 SDA 线，正常情况下会呈现以下典型特征
替代方法
（1）使用硬件逻辑分析仪
原理：直接连接 SDA/SCL 引脚，实时采集物理电平变化，不受 MCU 软件或仿真环境影响。
优势：能捕捉真实硬件交互中的细节
（2）用示波器单通道 / 双通道采集
方法：将示波器探头接 SDA或同时接 SDA 和 SCL，通过触发功能观察波形。
优势：可直观看到信号的幅值、噪声，判断硬件接线或电源问题。
